package com.example;


import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import java.util.Collections;

import org.junit.Test;

import io.netty.buffer.Unpooled;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.DecoderResult;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpRequestDecoder;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.util.CharsetUtil;

public class Testcase1 {



    @Test
    public void testHeaderWithNoValueAndMissingColon() throws Exception {
       String requestStr = "GET /one HTTP/1.1\r\n" +
                "Host: localhost\r\n" +
                "Transfer-Encoding: chunked\r\n\r\n" +
                "2;\n" + // Chunk size followed by illegal single newline (not preceded by carraige return)
                "xx\r\n" +
                "45\r\n" +
                "0\r\n\r\n" +
                "GET /two HTTP/1.1\r\n" +
                "Host: localhost\r\n" +
                "Transfer-Encoding: chunked\r\n\r\n" +
                "0\r\n\r\n";
        EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
        assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));
        HttpRequest request = channel.readInbound();
        assertFalse(request.decoderResult().isFailure()); // We parse the headers just fine.
        assertTrue(request.headers().names().contains("Transfer-Encoding"));
        assertTrue(request.headers().contains("Transfer-Encoding", "chunked", false));
        HttpContent content = channel.readInbound();
        DecoderResult decoderResult = content.decoderResult();
        assertTrue(decoderResult.isFailure()); // But parsing the chunk must fail.
    }

}
